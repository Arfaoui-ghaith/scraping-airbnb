"use strict";

exports.__esModule = true;
exports.extractDateFromText = extractDateFromText;
exports.getAllDatesFromText = getAllDatesFromText;
var chrono = _interopRequireWildcard(require("chrono-node"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function createDateParser() {
  var parser = chrono.en.GB.clone();
  function certainYearRefiner(_, results) {
    // If there is no AM/PM (meridiem) specified,
    //  let all time between 1:00 - 4:00 be PM (13.00 - 16.00)
    var filteredResults = [];
    results.forEach(function (result) {
      if (result.start.isCertain('day') && result.start.isCertain('month') && result.start.isCertain('year') &&
      // Weird bug in chrono 2016-06-18
      result.start.get('day') !== 0) {
        filteredResults.push(result);
      }
    });
    return filteredResults;
  }
  parser.refiners.push({
    refine: certainYearRefiner
  });
  return parser;
}
function monthNameRegexp() {
  return 'Jan(?:uary|\\.)?|Feb(?:ruary|\\.)?|Mar(?:ch|\\.)?|Apr(?:il|\\.)?|May|Jun(?:e|\\.)?|Jul(?:y|\\.)?|Aug(?:ust|\\.)?|Sep(?:tember|\\.)?|Oct(?:ober|\\.)?|Nov(?:ember|\\.)?|Dec(?:ember|\\.)?' + '|' + 'Ene(?:ro|\\.)?|Feb(?:rero|\\.)?|Mar(?:zo|\\.)?|Abr(?:il|\\.)?|May(?:o|\\.)?|Jun(?:io|\\.)?|Jul(?:io|\\.)?|Ago(?:sto|\\.)?|Sep(?:tiembre|\\.)?|Oct(?:ubre|\\.)?|Nov(?:iembre|\\.)?|Dic(?:iembre|\\.)?';
}
function prepareText(text) {
  return text
  // Incorrectly scanned hyphens
  .replace(/[\u2013\u2014\u2012\uFE58/]{1}/gi, '-')
  // Incorrectly scanned dd/mm/yyyy date, e.g. dd\'mm\'yyyy
  // Example: 01\'01\'2016 -> 01/01/2016
  .replace(new RegExp('(^|\\s)' +
  // (d)d?(?)
  '(?:([0-3]{0,1}[0-9]{1})[^a-z0-9]{1,2})' +
  // (m)m?(?)
  '(?:([0-3]{0,1}[0-9]{1})[^a-z0-9]{1,2})' +
  // yyyy
  '([1-9]{1}[0-9]{3})' + '(?=$|\\s)', 'ig'), '$1$2/$3/$4')
  // Incorrect format MMM dd yyyy
  // Example: Jan01 2016 -> Jan 01 2016
  .replace(new RegExp("(^|\\s)" + ( // monthname?
  "(?:(" + monthNameRegexp() + ")[^a-z0-9]{0,2})") + // (d)d?(?)
  "(?:(" + "[0-3]{0,1}[0-9]{1}" + ")[^a-z0-9]{1,2})" + // yyyy
  "([1-9]{1}[0-9]{3})" + "(?=$|\\s)", 'ig'), '$1$2 $3 $4')
  // Incorrect format dd MMM yyyy
  // Example: 01Jan 2016 -> 01 Jan 2016
  .replace(new RegExp("(^|\\s)" + // (d)d?(?)
  "(?:(" + "[0-3]{0,1}[0-9]{1}" + ")[^a-z0-9]{1,2})" + ( // monthname?
  "(?:(" + monthNameRegexp() + ")[^a-z0-9]{1,2})") + // yyyy
  "([1-9]{1}[0-9]{3})" + "(?=$|\\s)", 'ig'), '$1$2 $3 $4')
  // Incorrectly scanned ..Thh;ii;ss
  // Example: T12;45;59 -> T12:45:59
  .replace(new RegExp(
  // Thh
  'T([0-1][0-9]|2[0-4])' +
  // seperator
  '[^a-z0-9]{1}' +
  // ii
  '([0-5][0-9])' +
  // seperator
  '[^a-z0-9]{1}' +
  // ss
  '([0-5][0-9])' + '(?=$|\\s)', 'ig'), 'T$1:$2:$3');
}
function extractEarliest(values) {
  var minFound;
  values.forEach(function (value) {
    if (!minFound || value.start.date() < minFound) {
      minFound = value.start.date();
    }
  });
  return minFound;
}
function extractFirst(values) {
  if (values.length > 0) {
    return values[0].start.date();
  }
}
function extractDateFromText(text, options) {
  var _ref = options != null ? options : {},
    _ref$type = _ref.type,
    type = _ref$type === void 0 ? 'earliest' : _ref$type;
  var preparedText = prepareText(text);
  var dates = getAllDatesFromText(preparedText);
  var result;
  if (type === 'earliest') {
    result = extractEarliest(dates);
  } else {
    result = extractFirst(dates);
  }
  if (!result) {
    return null;
  }
  return result.toISOString().slice(0, 10);
}
function getAllDatesFromText(text) {
  return createDateParser().parse(text);
}
//# sourceMappingURL=extract-date.js.map