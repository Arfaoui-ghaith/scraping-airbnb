/* eslint-disable quotes */
'use strict';

const currencies = require('./currencies');

// Construct regular expressions

const allSymbols = currencies
    .reduce((syms, curr) => syms.concat(curr.code).concat(curr.symbols), [])
    .map(sym => sym.replace(/([\$\.])/g, '\\$1'))
    .join('|');
const minuses = '[−–‑—‒-]';
const delimiters = `[\\s.,\\'‘’‛′´\`]`;
const numGroup = `(\\s*\\d+(?:${delimiters}*\\d+)*)`;
const symGroup = `(${allSymbols})`;

const leadingSym = [minuses + '?', symGroup, minuses + '?', numGroup].join('\\s*');
const trailingSym = [minuses + '?', numGroup, symGroup].join('\\s*');

const startDelimiter = '(?:^|\\s+)';
const endDelimiter = `(?=$|\\s+|[,;:\\!\\?\\.\\'"\\+\\-])`;
const mainGroups = `(?:\\s*${[leadingSym, trailingSym].join('|')})`;

const priceRegex = new RegExp(`${startDelimiter}${mainGroups}${endDelimiter}`, 'ig');

exports.parseAll = parseAll;
exports.parseFirst = parseFirst;
exports.currencies = currencies;

function parseAll(text, options = {}) {
    text = String(text || '');
    if (!text) {
        return [];
    }
    priceRegex.lastIndex = 0;
    const results = [];
    performNextMatch();
    return results;

    function performNextMatch() {
        const m = priceRegex.exec(text);
        if (m) {
            const result = matchResultToPrice(m, options);
            if (result) {
                results.push(result);
            }
            performNextMatch();
        }
    }
}

function parseFirst(text, options = {}) {
    text = String(text || '');
    if (!text) {
        return null;
    }
    priceRegex.lastIndex = 0;
    const m = priceRegex.exec(text);
    return m ? matchResultToPrice(m, options) : null;
}

function matchResultToPrice(match, options = {}) {
    const {
        parseNegative = false,
    } = options;
    const isNegative = new RegExp(minuses).test(match[0]);
    const symbol = (match[1] || match[4] || '').toLowerCase();
    const currency = currencies.find(cur => cur.code === symbol ||
        cur.symbols.indexOf(symbol) > -1);
    if (!currency) {
        // Assertion note: this should not happen if regex are assembled correctly
        // tests should cover that
        return null;
    }
    const exponent = currency.exponent;
    const sign = parseNegative && isNegative ? -1 : 1;
    const floatValue = sign * parseNumber(match[2] || match[3], exponent);
    const value = Math.round(floatValue * Math.pow(10, exponent));
    return {
        value,
        floatValue,
        symbol,
        currencyCode: currency.code,
        currency,
    };
}

function parseNumber(str, exponent) {
    const chunks = str.split(new RegExp(delimiters + '+'));
    const num = parseInt(chunks.join(''));
    const lastChunk = chunks[chunks.length - 1];
    const hasDecimalPoint = chunks.length > 1 &&
        lastChunk.length <= exponent;
    const actualExponent = lastChunk.length;
    return hasDecimalPoint ? num / Math.pow(10, actualExponent) : num;
}
